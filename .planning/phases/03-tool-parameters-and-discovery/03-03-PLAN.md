---
phase: 03-tool-parameters-and-discovery
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - src/oneappServer.ts
  - netlify/functions/mcp.ts
autonomous: true

must_haves:
  truths:
    - "LLM can call list_clients to see all available client IDs"
    - "list_clients response includes client names when configured"
    - "Single MCP server instance handles all clients (no per-client caching)"
  artifacts:
    - path: "src/oneappServer.ts"
      provides: "list_clients tool"
      contains: "list_clients"
    - path: "netlify/functions/mcp.ts"
      provides: "Single server initialization"
      contains: "buildOneAppServer()"
  key_links:
    - from: "src/oneappServer.ts"
      to: "src/config.ts"
      via: "getClientIds, clientsConfig"
      pattern: "getClientIds|clientsConfig"
    - from: "netlify/functions/mcp.ts"
      to: "src/oneappServer.ts"
      via: "single buildOneAppServer call"
      pattern: "buildOneAppServer\\(\\)"
---

<objective>
Create list_clients discovery tool and update function handler to use single server instance.

Purpose: Fulfills DISC-01 and DISC-02 requirements. LLMs can discover available clients without prior knowledge.
Output: list_clients tool, simplified mcp.ts handler with single server
</objective>

<execution_context>
@/Users/gonzo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gonzo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-tool-parameters-and-discovery/03-RESEARCH.md
@.planning/phases/03-tool-parameters-and-discovery/03-01-SUMMARY.md
@.planning/phases/03-tool-parameters-and-discovery/03-02-SUMMARY.md
@src/oneappServer.ts
@src/config.ts
@netlify/functions/mcp.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add list_clients discovery tool</name>
  <files>src/oneappServer.ts</files>
  <action>
Add list_clients tool to oneappServer.ts. This tool requires no parameters and returns all available client IDs with optional metadata.

Add import at top (if not already present):
```typescript
import { getClientIds, clientsConfig } from './config.js';
```

Add tool after the existing tools (before `return server;`):

```typescript
// Discovery tool - list available clients
server.tool(
  'list_clients',
  'Returns all available client IDs that can be used with other tools. Use this to discover which clients are configured before making API calls.',
  async () => {
    const clientIds = getClientIds();

    const clients = clientIds.map(id => {
      const config = clientsConfig[id];
      return {
        id,
        name: config.name || null,
        description: config.description || null,
      };
    });

    return {
      content: [{
        type: 'text',
        text: JSON.stringify({ clients }, null, 2)
      }]
    };
  }
);
```

**Response format:**
```json
{
  "clients": [
    { "id": "sechpos", "name": "SECH POS", "description": "Retail POS client" },
    { "id": "acme", "name": null, "description": null }
  ]
}
```

The name and description come from optional fields in ClientConfig (added in Plan 01).
If not configured, they're null (not omitted) for consistent structure.
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile without errors.
Verify list_clients tool is defined (grep for 'list_clients').
  </verify>
  <done>list_clients tool exists and returns available client IDs with optional metadata.</done>
</task>

<task type="auto">
  <name>Task 2: Simplify mcp.ts to use single server</name>
  <files>netlify/functions/mcp.ts</files>
  <action>
Update netlify/functions/mcp.ts to use a single MCP server instance instead of per-client caching.

**Changes:**

1. Remove imports that are no longer needed:
```typescript
// REMOVE these:
import { validateClientHeader, createErrorResponse, ERROR_CODES, createUnknownClientError } from '../../src/routing.js';
import { serverCache } from '../../src/cache.js';
import { getClientConfig } from '../../src/config.js';
```

2. Update buildOneAppServer import (it no longer takes config):
```typescript
import { buildOneAppServer } from '../../src/oneappServer.js';
```

3. Create single server instance at module level (outside handler):
```typescript
// Single MCP server instance - handles all clients via clientId parameter
const mcpServer = buildOneAppServer();
```

4. Remove all header validation and per-client server logic from the handler.

**Before (inside handler):**
```typescript
// === Multi-tenant routing ===
const headerValidation = validateClientHeader(req.headers);
if (!headerValidation.success) {
  const status = headerValidation.error.code === ERROR_CODES.DUPLICATE_CLIENT_ID ? 400 : 403;
  return createErrorResponse(headerValidation.error, status);
}

const clientId = headerValidation.clientId;

const clientConfig = getClientConfig(clientId);
if (!clientConfig) {
  return createErrorResponse(createUnknownClientError(clientId), 403);
}

let mcpServer = serverCache.get(clientId);
if (!mcpServer) {
  mcpServer = buildOneAppServer(clientConfig);
  serverCache.set(clientId, mcpServer);
  console.log(`Created new MCP server for client: ${clientId}`);
} else {
  console.log(`Reusing cached MCP server for client: ${clientId}`);
}
```

**After:**
Remove all of the above. The `mcpServer` is already available at module level.

**IMPORTANT:** During Phase 3, we want BACKWARD COMPATIBILITY. Keep header validation but make it OPTIONAL:

Actually, let me reconsider. Per RESEARCH.md:
> During Phase 3, header routing still provides the client context. Tools with clientId parameter can work independently. Both paths should work.

For backward compatibility, keep the header validation but DON'T require it to succeed. If header is present and valid, log it. If missing or invalid, proceed anyway (tools handle their own clientId validation).

**Revised approach for Task 2:**

```typescript
// At top of handler, after POST check:
// Log client ID from header if present (backward compat, not required)
const clientIdHeader = req.headers.get('x-client-id');
if (clientIdHeader) {
  console.log(`Request has X-Client-ID header: ${clientIdHeader}`);
}

// Use module-level mcpServer (no per-client caching needed)
```

This means:
- Remove serverCache import and usage
- Remove getClientConfig import and validation
- Remove createErrorResponse/ERROR_CODES imports
- Keep a simple header log for debugging
- Remove buildOneAppServer(clientConfig) call - use module-level server

The full handler becomes simpler since tool-level validation handles client resolution.
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile without errors.
Run `netlify dev` or `netlify functions:serve` briefly to verify function loads.
  </verify>
  <done>
mcp.ts uses single buildOneAppServer() call at module level.
Header validation removed (tools handle clientId via parameter).
Per-client server caching removed.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. list_clients tool exists in oneappServer.ts
3. mcp.ts has `const mcpServer = buildOneAppServer()` at module level
4. mcp.ts no longer imports serverCache, getClientConfig, routing helpers
5. No header validation that would reject requests without X-Client-ID
</verification>

<success_criteria>
- DISC-01: list_clients tool returns available client IDs
- DISC-02: Response includes names/descriptions when configured
- Single server instance (no per-client caching)
- Backward compatibility: requests with header still work
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-tool-parameters-and-discovery/03-03-SUMMARY.md`
</output>

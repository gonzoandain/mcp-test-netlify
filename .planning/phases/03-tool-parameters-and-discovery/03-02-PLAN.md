---
phase: 03-tool-parameters-and-discovery
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/oneappServer.ts
  - src/httpClient.ts
autonomous: true

must_haves:
  truths:
    - "Every tool accepts clientId as first required parameter"
    - "Tool call with unknown clientId returns isError:true with valid client list"
    - "Tool call with valid clientId executes against that client's API"
  artifacts:
    - path: "src/oneappServer.ts"
      provides: "All tools with clientId parameter"
      contains: "clientId: z.string()"
    - path: "src/httpClient.ts"
      provides: "Standalone HTTP helper accepting config"
      exports: ["httpJson"]
  key_links:
    - from: "src/oneappServer.ts"
      to: "src/validation.ts"
      via: "validateClientId in every handler"
      pattern: "validateClientId\\(clientId\\)"
    - from: "src/oneappServer.ts"
      to: "src/httpClient.ts"
      via: "httpJson(config, ...)"
      pattern: "httpJson\\(.*config"
---

<objective>
Refactor all existing tools to accept clientId as first required parameter and validate it before executing API calls.

Purpose: Fulfills TOOL-01, TOOL-02, TOOL-03 requirements. LLMs can now specify which client to query without header configuration.
Output: All 15 tools accept clientId, validate it, and use corresponding config for API calls.
</objective>

<execution_context>
@/Users/gonzo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gonzo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-tool-parameters-and-discovery/03-RESEARCH.md
@.planning/phases/03-tool-parameters-and-discovery/03-01-SUMMARY.md
@src/oneappServer.ts
@src/validation.ts
@src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract httpJson to standalone module</name>
  <files>src/httpClient.ts</files>
  <action>
Extract the httpJson helper from the buildOneAppServer closure into a standalone module that accepts config as parameter.

Create `src/httpClient.ts`:

```typescript
import { ClientConfig } from './types.js';

const DEFAULT_HTTP_TIMEOUT_MS = 30000;

/**
 * Make authenticated HTTP request using client config.
 * Extracted from oneappServer.ts closure pattern.
 *
 * @param config - Client configuration with auth and URLs
 * @param baseUrl - Base URL for the request
 * @param path - API path to append
 * @param options - Fetch options
 */
export async function httpJson<T>(
  config: ClientConfig,
  baseUrl: string,
  path: string,
  options: RequestInit = {}
): Promise<T> {
  const timeoutMs = config.httpTimeoutMs ?? DEFAULT_HTTP_TIMEOUT_MS;
  const url = new URL(path, baseUrl);

  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    ...options.headers as Record<string, string>,
  };

  if (config.authorization) {
    headers['Authorization'] = config.authorization;
  }

  if (config.clientHeader) {
    headers['client'] = config.clientHeader;
  }

  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

  try {
    const response = await fetch(url.toString(), {
      ...options,
      headers,
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('HTTP Error Response:', {
        status: response.status,
        statusText: response.statusText,
        headers: Object.fromEntries(response.headers.entries()),
        body: errorText
      });
      throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorText}`);
    }

    return response.json();
  } catch (error) {
    clearTimeout(timeoutId);
    if (error instanceof Error && error.name === 'AbortError') {
      throw new Error(`Request timeout after ${timeoutMs}ms`);
    }
    throw error;
  }
}
```

This is a direct extraction with config as first parameter instead of closure capture.
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile without errors.
  </verify>
  <done>src/httpClient.ts exists with httpJson export accepting config as parameter.</done>
</task>

<task type="auto">
  <name>Task 2: Refactor oneappServer.ts tools with clientId parameter</name>
  <files>src/oneappServer.ts</files>
  <action>
Refactor `buildOneAppServer()` to:
1. NOT accept config at construction (single server for all clients)
2. Each tool accepts `clientId` as first required parameter
3. Each handler validates clientId and retrieves config
4. Use extracted httpJson(config, ...) instead of closure

The function signature changes from:
```typescript
export function buildOneAppServer(config: ClientConfig): McpServer
```
to:
```typescript
export function buildOneAppServer(): McpServer
```

Update imports at top:
```typescript
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { validateClientId, createClientIdErrorResult } from './validation.js';
import { httpJson } from './httpClient.js';
```

Remove the internal httpJson function and DEFAULT_HTTP_TIMEOUT_MS constant.

For EACH of the 15 tools, apply this pattern:

**Before (example - core_list_sucursales):**
```typescript
server.tool(
  'core_list_sucursales',
  'Obtiene la lista completa de sucursales...',
  async () => {
    const data = await httpJson<any>(config.coreBaseUrl, '/core/sucursales', { method: 'GET' });
    return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
  }
);
```

**After:**
```typescript
server.tool(
  'core_list_sucursales',
  'Obtiene la lista completa de sucursales registradas para el cliente especificado.',
  {
    clientId: z.string().describe('Client identifier (e.g., "sechpos", "acme")')
  },
  async ({ clientId }) => {
    const validation = validateClientId(clientId);
    if (!validation.success) {
      return createClientIdErrorResult(validation.error);
    }
    const { config } = validation;

    const data = await httpJson<any>(config, config.coreBaseUrl, '/core/sucursales', { method: 'GET' });
    return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
  }
);
```

**For tools that already have parameters**, prepend clientId:

**Before (core_list_zonas):**
```typescript
server.tool(
  'core_list_zonas',
  '...',
  {
    zone_id: z.number().int().optional().describe('ID de la zona')
  },
  async ({ zone_id }) => { ... }
);
```

**After:**
```typescript
server.tool(
  'core_list_zonas',
  '...',
  {
    clientId: z.string().describe('Client identifier (e.g., "sechpos", "acme")'),
    zone_id: z.number().int().optional().describe('ID de la zona')
  },
  async ({ clientId, zone_id }) => {
    const validation = validateClientId(clientId);
    if (!validation.success) {
      return createClientIdErrorResult(validation.error);
    }
    const { config } = validation;

    // ... rest of handler using config
  }
);
```

**Complete list of tools to update (15 total):**
1. core_list_sucursales
2. core_list_zonas
3. core_list_subgerencias
4. core_list_zonas_by_subgerencia
5. core_list_sucursales_by_zona
6. checklist_list_checks
7. checklist_list_ambitos
8. checklist_list_preguntas
9. checklist_list_cuestionarios
10. checklist_list_asignaciones
11. checklist_list_respuestas
12. visual_areas
13. visual_categorias
14. visual_area_categorias
15. visual_razones
16. visual_area_categoria_razones
17. moai_visapp_foto
18. moai_visapp_foto_info

(Note: count is 18, not 15 - update all of them)

**Key changes:**
- Remove `config: ClientConfig` parameter from buildOneAppServer
- Remove internal httpJson function
- Import validateClientId, createClientIdErrorResult from validation.ts
- Import httpJson from httpClient.ts
- Add clientId parameter to every tool schema
- Add validation block at start of every handler
- Update httpJson calls: `httpJson(config, baseUrl, ...)` instead of `httpJson(baseUrl, ...)`
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile without errors.
Verify all 18 tools have clientId in their schema.
  </verify>
  <done>
All tools in oneappServer.ts accept clientId as first required parameter.
buildOneAppServer() no longer accepts config parameter.
Each handler validates clientId and returns isError:true on invalid.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `src/httpClient.ts` exists with httpJson export
3. `buildOneAppServer()` has no parameters
4. Count tool definitions in oneappServer.ts - all should have `clientId: z.string()`
5. Each tool handler starts with `validateClientId(clientId)` check
</verification>

<success_criteria>
- TOOL-01: Every tool accepts clientId as first required parameter
- TOOL-02: Invalid clientId returns isError:true with valid client list
- TOOL-03: Valid clientId uses corresponding config for API calls
- httpJson extracted to standalone module
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-tool-parameters-and-discovery/03-02-SUMMARY.md`
</output>

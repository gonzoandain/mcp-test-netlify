---
phase: 03-tool-parameters-and-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types.ts
  - src/validation.ts
autonomous: true

must_haves:
  truths:
    - "ClientConfig type supports optional name and description fields"
    - "validateClientId helper returns config or error result"
    - "Error result includes list of valid client IDs for self-correction"
  artifacts:
    - path: "src/types.ts"
      provides: "Extended ClientConfig with optional name/description"
      contains: "name?: string"
    - path: "src/validation.ts"
      provides: "clientId validation helper for tool handlers"
      exports: ["validateClientId", "ClientValidationResult"]
  key_links:
    - from: "src/validation.ts"
      to: "src/config.ts"
      via: "imports getClientConfig, getClientIds"
      pattern: "import.*getClientConfig.*from.*config"
---

<objective>
Create infrastructure for clientId-based tool execution: extend types to support client metadata and create validation helper that tools will use.

Purpose: Foundation layer that tool handlers depend on. Must be in place before refactoring tools.
Output: Extended ClientConfig type, validateClientId helper function
</objective>

<execution_context>
@/Users/gonzo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gonzo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-tool-parameters-and-discovery/03-RESEARCH.md
@src/types.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ClientConfig type with optional metadata</name>
  <files>src/types.ts</files>
  <action>
Add optional `name` and `description` fields to ClientConfig interface:

```typescript
export interface ClientConfig {
  // ... existing fields ...

  /** Human-readable name for this client (optional, for LLM discovery) */
  name?: string;
  /** Description of this client (optional, for LLM discovery) */
  description?: string;
}
```

These fields support DISC-02 requirement: list_clients includes names/descriptions when configured. Fields are optional to maintain backward compatibility with existing CLIENTS_CONFIG JSON.

Do NOT modify ClientsConfig type - it's already `Record<string, ClientConfig>` which will inherit the new optional fields.
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile without errors.
Verify existing config.ts still works (no required field added).
  </verify>
  <done>ClientConfig interface has optional name and description fields. TypeScript compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Create validateClientId helper module</name>
  <files>src/validation.ts</files>
  <action>
Create new module `src/validation.ts` with clientId validation helper for tool handlers.

```typescript
import { ClientConfig } from './types.js';
import { getClientConfig, getClientIds } from './config.js';

/**
 * Result type for clientId validation in tool handlers.
 * Discriminated union for type-safe error handling.
 */
export type ClientValidationResult =
  | { success: true; config: ClientConfig }
  | { success: false; error: string };

/**
 * Validate clientId and return config or error.
 * Used at the start of every tool handler.
 *
 * @param clientId - The client identifier from tool parameters
 * @returns Config on success, error message with valid IDs on failure
 */
export function validateClientId(clientId: string): ClientValidationResult {
  // Normalize: trim and lowercase (matching routing.ts pattern)
  const normalized = clientId.trim().toLowerCase();

  // Validate format: alphanumeric and underscores only
  if (!/^[a-z0-9_]+$/.test(normalized)) {
    const validIds = getClientIds();
    return {
      success: false,
      error: `Invalid client ID format: "${clientId}". Must contain only lowercase alphanumeric characters and underscores. Valid clients: ${validIds.join(', ')}`,
    };
  }

  // Look up config
  const config = getClientConfig(normalized);
  if (!config) {
    const validIds = getClientIds();
    return {
      success: false,
      error: `Unknown client ID: "${clientId}". Valid clients: ${validIds.join(', ')}`,
    };
  }

  return { success: true, config };
}

/**
 * Create MCP tool error result for invalid clientId.
 * Returns isError: true so LLM sees the error and can retry.
 */
export function createClientIdErrorResult(errorMessage: string) {
  return {
    content: [{ type: 'text' as const, text: errorMessage }],
    isError: true,
  };
}
```

Key design decisions (from RESEARCH.md):
- Use `isError: true` for business logic errors (not JSON-RPC protocol errors)
- Always include valid client IDs in error message for LLM self-correction
- Normalize clientId same way as routing.ts (trim + lowercase)
- Return discriminated union for type-safe handling in tool code
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile without errors.
Verify imports resolve correctly.
  </verify>
  <done>
validation.ts exists with validateClientId and createClientIdErrorResult exports.
TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `src/types.ts` contains `name?: string` and `description?: string` in ClientConfig
3. `src/validation.ts` exports `validateClientId` and `createClientIdErrorResult`
4. No changes to existing functionality (config.ts still loads configs)
</verification>

<success_criteria>
- ClientConfig type extended with optional name/description (DISC-02 support)
- validateClientId helper created and exported
- Error messages include list of valid client IDs
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-tool-parameters-and-discovery/03-01-SUMMARY.md`
</output>

---
phase: 01-foundation-refactoring
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/types.ts
  - src/config.ts
autonomous: true

must_haves:
  truths:
    - "CLIENTS_CONFIG env var is parsed into typed ClientsConfig object"
    - "Config parsing happens once at module load, not per-request"
    - "Server can be instantiated with config for any client defined in CLIENTS_CONFIG"
    - "Invalid JSON in CLIENTS_CONFIG throws descriptive error at startup"
  artifacts:
    - path: "src/types.ts"
      provides: "ClientsConfig type (record of ClientConfig by ID)"
      exports: ["ClientConfig", "ClientsConfig"]
    - path: "src/config.ts"
      provides: "Parsed CLIENTS_CONFIG and accessor function"
      exports: ["clientsConfig", "getClientConfig"]
  key_links:
    - from: "src/config.ts"
      to: "process.env.CLIENTS_CONFIG"
      via: "JSON.parse at module load"
      pattern: "JSON\\.parse.*CLIENTS_CONFIG"
    - from: "src/config.ts"
      to: "src/types.ts"
      via: "import { ClientsConfig }"
      pattern: "import.*ClientsConfig.*from.*types"
---

<objective>
Add CLIENTS_CONFIG parsing to support multiple client configurations stored in a single env var.

Purpose: Enable multi-tenant configuration where all client configs are defined in one JSON env var, parsed once at startup, and accessible by client ID.

Output:
- Extended `src/types.ts` with ClientsConfig type
- New `src/config.ts` with config parsing and accessor
</objective>

<execution_context>
@/Users/gonzo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gonzo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-refactoring/01-01-SUMMARY.md
@src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ClientsConfig type</name>
  <files>src/types.ts</files>
  <action>
Extend `src/types.ts` to add the ClientsConfig type:

```typescript
/**
 * Record mapping client IDs to their configurations.
 * Parsed from CLIENTS_CONFIG env var (JSON).
 *
 * Example CLIENTS_CONFIG JSON:
 * {
 *   "client-a": {
 *     "authorization": "Bearer token-a",
 *     "coreBaseUrl": "https://api.oneapp.cl",
 *     "clientBaseUrl": "https://clienta.oneapp.cl",
 *     "clientHeader": "client-a-header"
 *   },
 *   "client-b": {
 *     "authorization": "Bearer token-b",
 *     "coreBaseUrl": "https://api.oneapp.cl",
 *     "clientBaseUrl": "https://clientb.oneapp.cl",
 *     "clientHeader": "client-b-header"
 *   }
 * }
 */
export type ClientsConfig = Record<string, ClientConfig>;
```

Keep the existing ClientConfig interface unchanged.
  </action>
  <verify>File compiles: `npx tsc --noEmit src/types.ts`</verify>
  <done>ClientsConfig type exported from src/types.ts as Record&lt;string, ClientConfig&gt;</done>
</task>

<task type="auto">
  <name>Task 2: Create config.ts with CLIENTS_CONFIG parsing</name>
  <files>src/config.ts</files>
  <action>
Create `src/config.ts` to parse and export client configurations:

```typescript
import { ClientConfig, ClientsConfig } from './types.js';

/**
 * Parse CLIENTS_CONFIG env var at module load time.
 * This ensures config is parsed once, not per-request.
 *
 * Falls back to legacy single-client env vars if CLIENTS_CONFIG is not set,
 * creating a "default" client entry for backward compatibility.
 */
function loadClientsConfig(): ClientsConfig {
  const configJson = process.env.CLIENTS_CONFIG;

  if (configJson) {
    try {
      const parsed = JSON.parse(configJson);

      // Validate structure: should be an object with string keys
      if (typeof parsed !== 'object' || parsed === null || Array.isArray(parsed)) {
        throw new Error('CLIENTS_CONFIG must be a JSON object mapping client IDs to configs');
      }

      // Basic validation of each client config
      for (const [clientId, config] of Object.entries(parsed)) {
        if (typeof config !== 'object' || config === null) {
          throw new Error(`CLIENTS_CONFIG["${clientId}"] must be an object`);
        }
        const c = config as Record<string, unknown>;
        if (typeof c.authorization !== 'string') {
          throw new Error(`CLIENTS_CONFIG["${clientId}"].authorization must be a string`);
        }
        if (typeof c.coreBaseUrl !== 'string') {
          throw new Error(`CLIENTS_CONFIG["${clientId}"].coreBaseUrl must be a string`);
        }
        if (typeof c.clientBaseUrl !== 'string') {
          throw new Error(`CLIENTS_CONFIG["${clientId}"].clientBaseUrl must be a string`);
        }
        if (typeof c.clientHeader !== 'string') {
          throw new Error(`CLIENTS_CONFIG["${clientId}"].clientHeader must be a string`);
        }
      }

      return parsed as ClientsConfig;
    } catch (error) {
      if (error instanceof SyntaxError) {
        throw new Error(`CLIENTS_CONFIG is not valid JSON: ${error.message}`);
      }
      throw error;
    }
  }

  // Fallback: build config from legacy single-client env vars
  // This maintains backward compatibility during transition
  console.log('CLIENTS_CONFIG not set, using legacy env vars with "default" client ID');

  return {
    default: {
      authorization: process.env.AUTHORIZATION || '',
      coreBaseUrl: process.env.CORE_BASE_URL || 'https://api.oneapp.cl',
      clientBaseUrl: process.env.CLIENT_BASE_URL || 'https://sechpos.oneapp.cl',
      clientHeader: process.env.CLIENT_HEADER || '',
      httpTimeoutMs: parseInt(process.env.HTTP_TIMEOUT_MS || '30000', 10),
    }
  };
}

/**
 * Parsed client configurations.
 * Loaded once at module initialization.
 */
export const clientsConfig: ClientsConfig = loadClientsConfig();

/**
 * Get configuration for a specific client ID.
 *
 * @param clientId - The client identifier
 * @returns ClientConfig if found, undefined if not
 */
export function getClientConfig(clientId: string): ClientConfig | undefined {
  return clientsConfig[clientId];
}

/**
 * Get all available client IDs.
 */
export function getClientIds(): string[] {
  return Object.keys(clientsConfig);
}
```

Key behaviors:
- Parses at module load (CONF-03: not per-request)
- Falls back to legacy env vars creating "default" client (backward compatible)
- Validates JSON structure and required fields
- Throws descriptive errors for invalid config
  </action>
  <verify>
Run `npm run build` - should compile without errors.
Run `node -e "import('./dist/src/config.js').then(m => console.log(m.getClientIds()))"` - should output ["default"] if no CLIENTS_CONFIG set.
  </verify>
  <done>
- src/config.ts created with loadClientsConfig, clientsConfig export, getClientConfig function
- Config parsed once at module load
- Fallback to legacy env vars with "default" client ID
- Validation errors thrown for invalid CLIENTS_CONFIG
  </done>
</task>

<task type="auto">
  <name>Task 3: Add documentation for CLIENTS_CONFIG format</name>
  <files>src/types.ts</files>
  <action>
Add a JSDoc comment block above the ClientConfig interface documenting the expected format:

```typescript
/**
 * Configuration for a single client.
 *
 * When using multi-tenant mode, store all client configs in CLIENTS_CONFIG env var:
 *
 * @example
 * // CLIENTS_CONFIG env var format:
 * {
 *   "sechpos": {
 *     "authorization": "Bearer token-sechpos",
 *     "coreBaseUrl": "https://api.oneapp.cl",
 *     "clientBaseUrl": "https://sechpos.oneapp.cl",
 *     "clientHeader": "sechpos-header-value"
 *   },
 *   "acme": {
 *     "authorization": "Bearer token-acme",
 *     "coreBaseUrl": "https://api.oneapp.cl",
 *     "clientBaseUrl": "https://acme.oneapp.cl",
 *     "clientHeader": "acme-header-value"
 *   }
 * }
 */
export interface ClientConfig {
  // ... existing fields
}
```

This documents the expected format for operators setting up CLIENTS_CONFIG in Netlify.
  </action>
  <verify>File compiles: `npm run build`</verify>
  <done>JSDoc documentation added to ClientConfig interface with CLIENTS_CONFIG format example</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. TypeScript compiles: `npm run build` succeeds
2. Types exported: `src/types.ts` exports both ClientConfig and ClientsConfig
3. Config module works: `src/config.ts` exports clientsConfig, getClientConfig, getClientIds
4. Fallback works: Without CLIENTS_CONFIG, creates "default" client from legacy env vars
5. Validation works: Invalid JSON or missing fields throw descriptive errors

Test fallback mode:
```bash
npm run build
node -e "import('./dist/src/config.js').then(m => console.log('Client IDs:', m.getClientIds()))"
# Should output: Client IDs: [ 'default' ]
```

Test with CLIENTS_CONFIG:
```bash
CLIENTS_CONFIG='{"test":{"authorization":"x","coreBaseUrl":"http://a","clientBaseUrl":"http://b","clientHeader":"c"}}' \
  node -e "import('./dist/src/config.js').then(m => console.log('Client IDs:', m.getClientIds()))"
# Should output: Client IDs: [ 'test' ]
```
</verification>

<success_criteria>
- ClientsConfig type defined as Record&lt;string, ClientConfig&gt;
- src/config.ts parses CLIENTS_CONFIG at module load
- Fallback to legacy env vars creates "default" client
- getClientConfig(clientId) returns correct config or undefined
- Invalid CLIENTS_CONFIG JSON throws descriptive error
- Existing single-client setup continues to work (backward compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-refactoring/01-02-SUMMARY.md`
</output>

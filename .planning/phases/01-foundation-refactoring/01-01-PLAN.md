---
phase: 01-foundation-refactoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types.ts
  - src/oneappServer.ts
autonomous: true

must_haves:
  truths:
    - "buildOneAppServer accepts a ClientConfig parameter"
    - "httpJson uses config passed to it, not module-level constants"
    - "ClientConfig type defines authorization, coreBaseUrl, clientBaseUrl, clientHeader"
  artifacts:
    - path: "src/types.ts"
      provides: "ClientConfig interface definition"
      exports: ["ClientConfig"]
    - path: "src/oneappServer.ts"
      provides: "Refactored server factory accepting config"
      exports: ["buildOneAppServer"]
      contains: "function buildOneAppServer(config: ClientConfig)"
  key_links:
    - from: "src/oneappServer.ts"
      to: "src/types.ts"
      via: "import { ClientConfig }"
      pattern: "import.*ClientConfig.*from.*types"
    - from: "httpJson function"
      to: "config parameter"
      via: "function parameter"
      pattern: "httpJson.*config.*ClientConfig"
---

<objective>
Refactor oneappServer to accept configuration as a parameter instead of reading from module-level constants.

Purpose: Enable multiple configs to coexist by making the server factory and HTTP client config-driven rather than env-var-driven.

Output:
- New `src/types.ts` with ClientConfig interface
- Refactored `buildOneAppServer(config: ClientConfig)`
- Refactored `httpJson()` that receives config via closure or parameter
</objective>

<execution_context>
@/Users/gonzo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gonzo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/ARCHITECTURE.md
@src/oneappServer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ClientConfig type</name>
  <files>src/types.ts</files>
  <action>
Create a new file `src/types.ts` with the ClientConfig interface:

```typescript
export interface ClientConfig {
  authorization: string;      // Bearer token or API key
  coreBaseUrl: string;        // Base URL for OneApp Core API
  clientBaseUrl: string;      // Base URL for OneApp Client API
  clientHeader: string;       // Client identifier header value
  httpTimeoutMs?: number;     // Optional timeout override (default 30000)
}
```

This type will be used by:
- `buildOneAppServer()` as its parameter type
- `httpJson()` for configuration values
- Future CLIENTS_CONFIG parsing (Plan 02)
  </action>
  <verify>File exists at `src/types.ts` with exported ClientConfig interface</verify>
  <done>ClientConfig interface exported from src/types.ts with all required fields</done>
</task>

<task type="auto">
  <name>Task 2: Refactor httpJson and buildOneAppServer to use config parameter</name>
  <files>src/oneappServer.ts</files>
  <action>
Refactor `src/oneappServer.ts` to make it config-driven:

1. Add import at top:
   ```typescript
   import { ClientConfig } from './types.js';
   ```

2. Remove module-level constants that will come from config:
   - Keep: `HTTP_TIMEOUT_MS` as fallback default (30000)
   - Keep: Development dotenv loading (for backward compatibility during transition)
   - Remove reliance on: `CORE_BASE`, `CLIENT_BASE`, `AUTHORIZATION`, `CLIENT_HEADER` as module constants

3. Move `httpJson` inside `buildOneAppServer` as a closure that captures the config:
   ```typescript
   export function buildOneAppServer(config: ClientConfig): McpServer {
     const timeoutMs = config.httpTimeoutMs ?? 30000;

     async function httpJson<T>(baseUrl: string, path: string, options: RequestInit = {}): Promise<T> {
       // Use config.authorization, config.clientHeader instead of module constants
       // ... existing logic but with config values
     }

     const server = new McpServer({ name: 'oneapp-mcp', version: '0.1.0' });
     // ... tool registrations using httpJson which now has config in closure
   }
   ```

4. Update all `httpJson` calls to use config values:
   - `CORE_BASE` -> `config.coreBaseUrl`
   - `CLIENT_BASE` -> `config.clientBaseUrl`
   - `AUTHORIZATION` -> `config.authorization`
   - `CLIENT_HEADER` -> `config.clientHeader`

5. For backward compatibility during transition, keep the module-level env var reading but only use it if no config is passed (optional - can be removed in Plan 02 when CLIENTS_CONFIG is integrated).

Important: Do NOT change the function signature of `buildOneAppServer` to have optional config yet - require it now. The calling code in `mcp.ts` will be updated in Plan 02.
  </action>
  <verify>
Run `npm run build` - should compile without errors.
Grep for "CORE_BASE" in oneappServer.ts - should not find module-level constant usage in httpJson.
  </verify>
  <done>
- buildOneAppServer accepts ClientConfig parameter
- httpJson uses config values from closure
- No module-level AUTHORIZATION/CLIENT_HEADER/CORE_BASE/CLIENT_BASE usage in request logic
  </done>
</task>

<task type="auto">
  <name>Task 3: Update mcp.ts to pass config (temporary hardcoded from env)</name>
  <files>netlify/functions/mcp.ts</files>
  <action>
Update `netlify/functions/mcp.ts` to construct config from env vars and pass to buildOneAppServer:

1. Add import:
   ```typescript
   import { ClientConfig } from '../../src/types.js';
   ```

2. Update `getServer()` function to build config from env vars:
   ```typescript
   function getServer(): McpServer {
     const config: ClientConfig = {
       authorization: process.env.AUTHORIZATION || '',
       coreBaseUrl: process.env.CORE_BASE_URL || 'https://api.oneapp.cl',
       clientBaseUrl: process.env.CLIENT_BASE_URL || 'https://sechpos.oneapp.cl',
       clientHeader: process.env.CLIENT_HEADER || '',
       httpTimeoutMs: parseInt(process.env.HTTP_TIMEOUT_MS || '30000', 10),
     };

     // Keep existing env hash logic for cache invalidation
     const envHash = [
       config.coreBaseUrl,
       config.clientBaseUrl,
       config.authorization,
       config.clientHeader,
     ].join('|');

     if (cached && cachedEnvHash !== envHash) {
       cached = null;
     }

     if (!cached) {
       cached = buildOneAppServer(config);
       cachedEnvHash = envHash;
     }

     return cached;
   }
   ```

This maintains backward compatibility - the server still works with existing env vars, but now uses the config-passing pattern that Phase 2 will extend for multi-tenancy.
  </action>
  <verify>
Run `npm run build` - should compile without errors.
Run `npm run dev` briefly and verify the server starts (if you have env vars set).
  </verify>
  <done>
- mcp.ts imports ClientConfig
- getServer constructs config from env vars
- buildOneAppServer called with config parameter
- Existing behavior preserved (same env vars, same caching)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. TypeScript compiles: `npm run build` succeeds
2. Type structure correct: `src/types.ts` exports ClientConfig
3. Server factory signature: `buildOneAppServer(config: ClientConfig)`
4. No direct env var usage in httpJson: grep confirms config values used
5. Integration preserved: mcp.ts passes config constructed from env vars
</verification>

<success_criteria>
- buildOneAppServer requires ClientConfig parameter (not optional)
- httpJson uses config.authorization, config.coreBaseUrl, etc.
- mcp.ts constructs config from process.env and passes to buildOneAppServer
- npm run build completes without errors
- Existing functionality preserved (same env vars work the same way)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-refactoring/01-01-SUMMARY.md`
</output>

---
phase: 02-multi-tenant-routing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/routing.ts
  - src/cache.ts
autonomous: true

must_haves:
  truths:
    - "validateClientHeader extracts and validates X-Client-ID header"
    - "ServerCache stores server instances with 5-minute TTL"
    - "Cache TTL resets on each access"
    - "Missing header returns MISSING_CLIENT_ID error"
    - "Invalid format returns INVALID_CLIENT_ID error"
  artifacts:
    - path: "src/routing.ts"
      provides: "Header validation, error response helpers"
      exports: ["validateClientHeader", "createErrorResponse", "ERROR_CODES", "RoutingError"]
    - path: "src/cache.ts"
      provides: "TTL-based server cache"
      exports: ["ServerCache", "serverCache"]
  key_links:
    - from: "src/routing.ts"
      to: "src/config.ts"
      via: "getClientConfig import"
      pattern: "import.*getClientConfig.*from.*config"
    - from: "src/cache.ts"
      to: "@modelcontextprotocol/sdk"
      via: "McpServer type import"
      pattern: "import.*McpServer.*from"
---

<objective>
Create routing and cache modules for multi-tenant request handling.

Purpose: Establish the core infrastructure for routing requests to client-specific server instances with TTL-based caching.

Output: Two new modules - `src/routing.ts` for header validation and error handling, `src/cache.ts` for per-client server caching with TTL eviction.
</objective>

<execution_context>
@/Users/gonzo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gonzo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-multi-tenant-routing/02-CONTEXT.md
@.planning/phases/02-multi-tenant-routing/02-RESEARCH.md
@src/config.ts
@src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create routing module with header validation and error helpers</name>
  <files>src/routing.ts</files>
  <action>
Create src/routing.ts with:

1. **ERROR_CODES constant object:**
   ```typescript
   export const ERROR_CODES = {
     MISSING_CLIENT_ID: 'MISSING_CLIENT_ID',
     DUPLICATE_CLIENT_ID: 'DUPLICATE_CLIENT_ID',
     INVALID_CLIENT_ID: 'INVALID_CLIENT_ID',
     UNKNOWN_CLIENT: 'UNKNOWN_CLIENT',
   } as const;
   ```

2. **RoutingError interface:**
   ```typescript
   export interface RoutingError {
     code: typeof ERROR_CODES[keyof typeof ERROR_CODES];
     message: string;
   }
   ```

3. **createErrorResponse function:**
   - Takes RoutingError and status number
   - Returns Response with JSON body: `{ "error": message, "code": code }`
   - Sets Content-Type: application/json header

4. **validateClientHeader function:**
   - Takes Headers object (Web API)
   - Returns discriminated union: `{ success: true; clientId: string } | { success: false; error: RoutingError }`
   - Implementation:
     a. Get 'x-client-id' header (case-insensitive via headers.get())
     b. If null: return MISSING_CLIENT_ID error
     c. If contains comma: return DUPLICATE_CLIENT_ID error (duplicate headers combined per HTTP spec)
     d. Trim whitespace, lowercase for normalization
     e. If empty after trim: return MISSING_CLIENT_ID error
     f. If not matching /^[a-z0-9]+$/: return INVALID_CLIENT_ID error
     g. Return success with normalized clientId

Error messages (per CONTEXT.md):
- MISSING_CLIENT_ID: "Missing X-Client-ID header. Provide client identifier."
- DUPLICATE_CLIENT_ID: "Multiple X-Client-ID headers detected. Provide exactly one."
- INVALID_CLIENT_ID: "Client ID must contain only alphanumeric characters (a-z, 0-9)."
- UNKNOWN_CLIENT: "Unknown client ID: {id}. Check X-Client-ID header value."

Do NOT import getClientConfig here - that check happens in mcp.ts during routing.
  </action>
  <verify>
Run: `npx tsc --noEmit`
TypeScript compiles without errors.
  </verify>
  <done>
src/routing.ts exists with validateClientHeader, createErrorResponse, ERROR_CODES, RoutingError exported. TypeScript compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create cache module with TTL-based server storage</name>
  <files>src/cache.ts</files>
  <action>
Create src/cache.ts with:

1. **CacheEntry interface (internal):**
   ```typescript
   interface CacheEntry {
     server: McpServer;
     timer: NodeJS.Timeout;
   }
   ```

2. **DEFAULT_TTL_MS constant:** 5 * 60 * 1000 (5 minutes, hardcoded per CONTEXT.md)

3. **ServerCache class:**
   - Private `cache = new Map<string, CacheEntry>()`
   - Private readonly `ttlMs: number`
   - Constructor takes optional ttlMs (defaults to DEFAULT_TTL_MS)

   **get(clientId: string): McpServer | undefined**
   - Get entry from Map
   - If not found, return undefined
   - If found:
     a. Clear existing timer: `clearTimeout(entry.timer)`
     b. Create new timer: `entry.timer = this.createEvictionTimer(clientId)`
     c. Return entry.server

   **set(clientId: string, server: McpServer): void**
   - Check if existing entry for clientId
   - If exists, clearTimeout on existing timer (prevent memory leak)
   - Set new entry with server and new eviction timer

   **has(clientId: string): boolean**
   - Return this.cache.has(clientId)

   **get size(): number**
   - Return this.cache.size (for testing/monitoring)

   **private createEvictionTimer(clientId: string): NodeJS.Timeout**
   - Create setTimeout that deletes cache entry after ttlMs
   - Call timer.unref() to not block process exit
   - Return timer

4. **Export singleton instance:**
   ```typescript
   export const serverCache = new ServerCache();
   ```

Import McpServer type from '@modelcontextprotocol/sdk/server/mcp.js'.
  </action>
  <verify>
Run: `npx tsc --noEmit`
TypeScript compiles without errors.
  </verify>
  <done>
src/cache.ts exists with ServerCache class and serverCache singleton exported. TTL is 5 minutes. Timer.unref() called. TypeScript compiles.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npx tsc --noEmit` passes
2. `src/routing.ts` exports: validateClientHeader, createErrorResponse, ERROR_CODES, RoutingError
3. `src/cache.ts` exports: ServerCache, serverCache
4. No circular dependencies between modules
</verification>

<success_criteria>
- routing.ts validates headers per CONTEXT.md rules (case-insensitive, alphanumeric, trim, detect duplicates)
- cache.ts implements TTL with reset-on-access behavior
- Both modules compile without TypeScript errors
- Modules are ready for integration in Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/02-multi-tenant-routing/02-01-SUMMARY.md`
</output>

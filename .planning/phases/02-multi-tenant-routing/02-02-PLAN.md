---
phase: 02-multi-tenant-routing
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - netlify/functions/mcp.ts
autonomous: true

must_haves:
  truths:
    - "Request with valid X-Client-ID gets response using that client's config"
    - "Request without X-Client-ID returns 403 with MISSING_CLIENT_ID"
    - "Request with unknown X-Client-ID returns 403 with UNKNOWN_CLIENT"
    - "Second request for same client reuses cached server (no re-init)"
    - "Different clients get different server instances"
  artifacts:
    - path: "netlify/functions/mcp.ts"
      provides: "Multi-tenant MCP endpoint with routing"
      contains: "validateClientHeader"
  key_links:
    - from: "netlify/functions/mcp.ts"
      to: "src/routing.ts"
      via: "validateClientHeader import"
      pattern: "import.*validateClientHeader.*from.*routing"
    - from: "netlify/functions/mcp.ts"
      to: "src/cache.ts"
      via: "serverCache import"
      pattern: "import.*serverCache.*from.*cache"
    - from: "netlify/functions/mcp.ts"
      to: "src/config.ts"
      via: "getClientConfig for unknown client check"
      pattern: "getClientConfig\\(clientId\\)"
---

<objective>
Integrate multi-tenant routing into the Netlify function handler.

Purpose: Complete the multi-tenant capability by wiring header validation, config lookup, and per-client server caching into the request flow.

Output: Updated `netlify/functions/mcp.ts` that routes requests based on X-Client-ID header and caches server instances per client.
</objective>

<execution_context>
@/Users/gonzo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gonzo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-multi-tenant-routing/02-CONTEXT.md
@.planning/phases/02-multi-tenant-routing/02-01-SUMMARY.md
@src/routing.ts
@src/cache.ts
@src/config.ts
@netlify/functions/mcp.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire routing and caching into mcp.ts handler</name>
  <files>netlify/functions/mcp.ts</files>
  <action>
Update netlify/functions/mcp.ts to implement multi-tenant routing:

**1. Update imports:**
```typescript
import { validateClientHeader, createErrorResponse, ERROR_CODES } from '../../src/routing.js';
import { serverCache } from '../../src/cache.js';
import { getClientConfig } from '../../src/config.js';
```

**2. Remove old caching code:**
- Delete `let cached: McpServer | null = null;`
- Delete `let cachedEnvHash: string | null = null;`
- Delete the entire `getServer()` function (replaced by serverCache + routing)

**3. Update handler function - add routing BEFORE any MCP processing:**

At the start of the handler (after method check), add:

```typescript
// === Multi-tenant routing ===
const headerValidation = validateClientHeader(req.headers);
if (!headerValidation.success) {
  // Per CONTEXT.md: 403 for missing/invalid, 400 for duplicate
  const status = headerValidation.error.code === ERROR_CODES.DUPLICATE_CLIENT_ID ? 400 : 403;
  return createErrorResponse(headerValidation.error, status);
}

const clientId = headerValidation.clientId;

// Check if client exists in config
const clientConfig = getClientConfig(clientId);
if (!clientConfig) {
  return createErrorResponse(
    {
      code: ERROR_CODES.UNKNOWN_CLIENT,
      message: `Unknown client ID: ${clientId}. Check X-Client-ID header value.`
    },
    403
  );
}

// Get or create server for this client (lazy init with TTL cache)
let mcpServer = serverCache.get(clientId);
if (!mcpServer) {
  mcpServer = buildOneAppServer(clientConfig);
  serverCache.set(clientId, mcpServer);
  console.log(`Created new MCP server for client: ${clientId}`);
} else {
  console.log(`Reusing cached MCP server for client: ${clientId}`);
}
```

**4. Update server.connect() calls:**

Replace all occurrences of:
```typescript
const server = getServer();
await server.connect(transport);
```

With:
```typescript
await mcpServer.connect(transport);
```

There are TWO places where server.connect() is called (around lines 97-98 and 133-134). Update BOTH.

**5. Remove unused import:**
- Remove `ClientConfig` import if no longer used (it's used indirectly via getClientConfig now)

**6. Keep transport caching as-is:**
- The `transports` object for session management stays unchanged
- Only the MCP server is now per-client cached via serverCache

**Key behavior changes:**
- OLD: Single global server, config from env vars
- NEW: Per-client server from serverCache, config from CLIENTS_CONFIG via clientId lookup

Error response format (per CONTEXT.md):
```json
{ "error": "message here", "code": "ERROR_CODE" }
```

HTTP status codes (per CONTEXT.md):
- Missing X-Client-ID: 403
- Invalid X-Client-ID format: 403
- Unknown client ID: 403
- Duplicate X-Client-ID headers: 400
  </action>
  <verify>
Run: `npx tsc --noEmit`
TypeScript compiles without errors.

Manual verification (after deployment or local test):
1. Request without X-Client-ID returns 403 + MISSING_CLIENT_ID
2. Request with valid client ID returns MCP response
3. Request with unknown client ID returns 403 + UNKNOWN_CLIENT
  </verify>
  <done>
mcp.ts routes requests based on X-Client-ID header. Uses serverCache for per-client caching. Returns structured JSON errors for missing/invalid/unknown clients. TypeScript compiles.
  </done>
</task>

</tasks>

<verification>
After task completes:
1. `npx tsc --noEmit` passes
2. No references to old `cached` or `getServer()` remain
3. All server.connect() calls use the routed mcpServer
4. Imports include routing.ts, cache.ts, config.ts
5. Handler returns early with error responses for invalid requests
</verification>

<success_criteria>
Per ROADMAP.md success criteria:
1. Request with X-Client-ID header gets response using that client's config
2. Request without X-Client-ID header returns 403 with "Missing X-Client-ID header"
3. Request with unknown X-Client-ID returns 403 with "Unknown client ID: [id]"
4. Second request for same client ID reuses cached server instance (console log confirms)
5. Requests for different clients use different server instances (via serverCache)
</success_criteria>

<output>
After completion, create `.planning/phases/02-multi-tenant-routing/02-02-SUMMARY.md`
</output>
